pipeline {
    agent {
        docker { // Optional: use a Docker-in-Docker agent or ensure Docker is available
            image 'jenkins/inbound-agent:latest' // Or any image with Docker CLI
            args '--docker-host=tcp://docker:2376 --docker-cert-path=/certs/client'
        }
    }
    environment {
        AWS_DEFAULT_REGION    = 'ap-south-1'
        AWS_ACCOUNT_ID        = '726661503021'
        ECR_REPO              = 'travelease-booking'  // Base name
        REPO_URI              = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com"

        // ‚úÖ Use one credentials ID that contains AWS_ACCESS_KEY_ID + AWS_SECRET_ACCESS_KEY
        AWS_CREDENTIALS_ID    = 'aws-credentials'  // Jenkins credentials ID (type: Username/Password)
    }
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Docker Login to ECR') {
            steps {
                script {
                    // üîê Retrieve credentials once
                    withCredentials([usernamePassword(
                        credentialsId: env.AWS_CREDENTIALS_ID,
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    )]) {
                        sh """
                            # Configure AWS CLI (optional, but helps)
                            aws configure set aws_access_key_id \$AWS_ACCESS_KEY_ID
                            aws configure set aws_secret_access_key \$AWS_SECRET_ACCESS_KEY
                            aws configure set region ${AWS_DEFAULT_REGION}

                            # Get login password and log in to ECR
                            aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | \
                                docker login --username AWS --password-stdin ${REPO_URI}
                        """
                    }
                }
            }
        }

        stage('Build & Push Images') {
            matrix {
                axes {
                    axis {
                        name 'SERVICE'
                        values 'booking', 'payment', 'user', 'frontend'
                    }
                }
                stages {
                    stage('Build') {
                        steps {
                            dir("services/${SERVICE}") {
                                script {
                                    def imageName = "${ECR_REPO}-${SERVICE}"
                                    def imageTag = "${env.REPO_URI}/${imageName}:${env.BUILD_NUMBER}"
                                    def latestTag = "${env.REPO_URI}/${imageName}:latest"

                                    echo "Building Docker image: ${imageTag}"

                                    // Build image
                                    docker.build(imageTag)

                                    // Tag as latest
                                    sh "docker tag ${imageTag} ${latestTag}"

                                    // Push both tags
                                    sh "docker push ${imageTag}"
                                    sh "docker push ${latestTag}"

                                    // Export image URI for Terraform
                                    env["IMAGE_URI_${SERVICE.toUpperCase()}"] = imageTag
                                }
                            }
                        }
                    }
                }
            }
        }

        stage('Terraform Apply') {
            steps {
                dir('infra/terraform') {
                    sh 'terraform init'

                    // Pass all image URIs to Terraform
                    sh """
                        terraform apply -auto-approve \
                            -var="booking_image_uri=${env.IMAGE_URI_BOOKING}" \
                            -var="payment_image_uri=${env.IMAGE_URI_PAYMENT}" \
                            -var="user_image_uri=${env.IMAGE_URI_USER}" \
                            -var="frontend_image_uri=${env.IMAGE_URI_FRONTEND}"
                    """
                }
            }
        }

        stage('ECS Redeploy (Optional Re-apply)') {
            steps {
                echo "üîÑ Triggering ECS redeployment via Terraform..."
                dir('infra/terraform') {
                    sh 'terraform apply -auto-approve -target=aws_ecs_service.booking -target=aws_ecs_service.payment -target=aws_ecs_service.user -target=aws_ecs_service.frontend'
                }
            }
        }
    }
    post {
        success {
            echo '‚úÖ Deployment succeeded!'
            slackSend channel: '#deployments', message: "‚úÖ Build ${env.BUILD_NUMBER} deployed successfully to ap-south-1!"
        }
        failure {
            echo '‚ùå Deployment failed!'
            slackSend channel: '#alerts', message: "‚ùå Build ${env.BUILD_NUMBER} failed!"
        }
        always {
            cleanWs()
            // Reset AWS config if needed
            sh 'aws configure set aws_access_key_id ""'
            sh 'aws configure set aws_secret_access_key ""'
        }
    }
}
